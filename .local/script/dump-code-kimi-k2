#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
dumpcode-fmt-final.py â€“ Dump kode ke SATU berkas dengan format:
========================================
=== namafile.ext ===
========================================
isi kode langsung dimulai tanpa newline di atasnya
Usage:
    python dumpcode-fmt-final.py ROOT [options]
"""

from __future__ import annotations
import os
import sys
import argparse
import signal
from pathlib import Path

CODE_EXTENSIONS = {
    ".py", ".js", ".ts", ".jsx", ".tsx", ".java", ".c", ".cpp", ".cxx", ".cc",
    ".h", ".hpp", ".cs", ".go", ".rs", ".swift", ".kt", ".kts", ".scala",
    ".rb", ".php", ".r", ".m", ".mm", ".pl", ".sh", ".bash", ".zsh", ".fish",
    ".ps1", ".bat", ".cmd", ".vbs", ".sql", ".html", ".htm", ".xml", ".css",
    ".scss", ".sass", ".less", ".vue", ".svelte", ".dart", ".lua", ".pas",
    ".pp", ".f", ".f90", ".f95", ".jl", ".elm", ".clj", ".cljs", ".ex",
    ".exs", ".erl", ".hrl", ".nim", ".nims", ".ml", ".mli", ".fs", ".fsx",
    ".fsi", ".vb", ".v", ".sv", ".svh", ".t", ".svp", ".groovy", ".gradle",
    ".tf", ".hcl", ".md",
}

SKIP_FOLDERS = {
    "node_modules", ".git", "__pycache__", "venv", ".venv", "env", ".env",
    "dist", "build", "target", ".pytest_cache", ".mypy_cache", ".idea",
    ".vscode", "coverage", ".nyc_output", "dll", "lib", "obj", ".next",
    ".nuxt", ".svelte-kit", "vendor", ".bundle", ".sass-cache",
}

CHUNK_SIZE = 1 << 20


def is_binary(path: Path) -> bool:
    try:
        with path.open("rb") as f:
            return b"\0" in f.read(1024)
    except Exception:
        return True


def should_skip_dir(name: str) -> bool:
    return name.lower() in SKIP_FOLDERS


def build_atoms(root: Path, base: Path) -> list[tuple[str, int]]:
    atoms: list[tuple[str, int]] = []
    for dirpath, dirnames, filenames in os.walk(base, followlinks=False):
        dp = Path(dirpath)
        rel_dp = dp.relative_to(root)
        if any(p.startswith(".") for p in rel_dp.parts):
            dirnames[:] = []
            continue
        for s in list(dirnames):
            if should_skip_dir(s):
                dirnames.remove(s)

        for fname in filenames:
            fp = dp / fname
            ext = fp.suffix.lower()
            # if ext not in CODE_EXTENSIONS:
            #     continue
            if not fp.is_file() or fp.is_symlink():
                continue
            if is_binary(fp):
                continue

            rel_file = fp.relative_to(root).as_posix()
            # PENTING: tanpa newline setelah header kedua
            header = f"========================================\n=== {rel_file} ===\n========================================\n"
            try:
                with fp.open("r", encoding="utf-8", errors="strict") as f:
                    content = f.read()
            except UnicodeDecodeError:
                continue

            block = header + content
            atoms.append((block, len(block.encode("utf-8"))))
    return atoms


def atomically_write(out_path: Path, max_bytes: int, atoms: list[tuple[str, int]]):
    total = sum(b for _, b in atoms)
    if total > max_bytes:
        print(
            f"Error: total calon output ({total / 1e6:.2f} MB) "
            f"melebihi --max-size ({max_bytes / 1e6:.2f} MB).\n"
            "Silakan naikkan --max-size atau gunakan --only.",
            file=sys.stderr,
        )
        sys.exit(2)

    tmp = out_path.with_suffix(out_path.suffix + ".tmp")
    try:
        with tmp.open("w", encoding="utf-8") as f:
            for blk, _ in atoms:
                for i in range(0, len(blk), CHUNK_SIZE):
                    f.write(blk[i : i + CHUNK_SIZE])
        tmp.replace(out_path)
    except Exception as e:
        try:
            tmp.unlink()
        except Exception:
            pass
        raise e


class CleanExit:
    def __init__(self, path: Path):
        self.path = path
        signal.signal(signal.SIGINT, self._handler)
        signal.signal(signal.SIGTERM, self._handler)

    def _handler(self, signum, frame):
        print("\nDiterima sinyal interrupt. Menghapus file setengah jalan...", file=sys.stderr)
        try:
            self.path.unlink()
        except Exception:
            pass
        sys.exit(130)


def main():
    parser = argparse.ArgumentParser(description="Dump kode ke satu berkas dengan format persis  (tanpa newline setelah header).")
    parser.add_argument("root", help="Root folder proyek")
    parser.add_argument("--only", help="Hanya proses sub-folder tertentu")
    parser.add_argument("--max-size", type=int, default=50, help="Maksimum MB output (default 50)")
    parser.add_argument("--out", default=".", help="Folder keluaran")
    args = parser.parse_args()

    root = Path(args.root).expanduser().resolve()
    if not root.is_dir():
        print("Error: ROOT bukan direktori", file=sys.stderr)
        sys.exit(1)

    base = root
    if args.only:
        base = root / args.only
        if not base.is_dir():
            print(f"Error: {args.only} bukan folder di bawah {root}", file=sys.stderr)
            sys.exit(1)

    out_dir = Path(args.out).expanduser().resolve()
    out_dir.mkdir(exist_ok=True)
    out_file = out_dir / f"dump_code-{root.name}.txt"

    atoms = build_atoms(root, base)
    if not atoms:
        print("Tidak ada file kode yang ditemukan.", file=sys.stderr)
        sys.exit(0)

    cleaner = CleanExit(out_file)
    atomically_write(out_file, args.max_size * 1_000_000, atoms)

    total_bytes = sum(b for _, b in atoms)
    print(f"Selesai. Output: {out_file}  ({total_bytes / 1e6:.2f} MB)")


if __name__ == "__main__":
    main()
