#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
dumpcode.py â€“ Dump seluruh file kode ke SATU berkas teks utuh tanpa memotong isi.
Final version: atomik, streaming, presisi ukuran, aman untuk file raksasa.
Usage:
    python dumpcode.py ROOT [options]
Options:
    --only SUB          Hanya proses sub-folder tertentu
    --max-size N        Maksimum ukuran output (MB) default 50
    --out DIR           Folder keluaran (default: cwd)
Output:
    dump_code-<ROOT_FOLDER>.txt
Setiap file kode ditulis utuh; tidak akan terpotong di tengah.
"""
from __future__ import annotations
import os
import sys
import argparse
import signal
from pathlib import Path

CODE_EXTENSIONS = {
    ".py", ".js", ".ts", ".jsx", ".tsx", ".java", ".c", ".cpp", ".cxx", ".cc",
    ".h", ".hpp", ".cs", ".go", ".rs", ".swift", ".kt", ".kts", ".scala",
    ".rb", ".php", ".r", ".m", ".mm", ".pl", ".sh", ".bash", ".zsh", ".fish",
    ".ps1", ".bat", ".cmd", ".vbs", ".sql", ".html", ".htm", ".xml", ".css",
    ".scss", ".sass", ".less", ".vue", ".svelte", ".dart", ".lua", ".pas",
    ".pp", ".f", ".f90", ".f95", ".jl", ".elm", ".clj", ".cljs", ".ex",
    ".exs", ".erl", ".hrl", ".nim", ".nims", ".ml", ".mli", ".fs", ".fsx",
    ".fsi", ".vb", ".v", ".sv", ".svh", ".t", ".svp", ".groovy", ".gradle",
}

SKIP_FOLDERS = {
    "node_modules", ".git", "__pycache__", "venv", ".venv", "env", ".env",
    "dist", "build", "target", ".pytest_cache", ".mypy_cache", ".idea",
    ".vscode", "coverage", ".nyc_output", "dll", "lib", "obj", ".next",
    ".nuxt", ".svelte-kit", "vendor", ".bundle", ".sass-cache",
}

CHUNK_SIZE = 1 << 20  # 1 MiB streaming


# ---------- util ----------
def is_binary(path: Path) -> bool:
    """True kalau tampak berisi null-byte di awal."""
    try:
        with path.open("rb") as f:
            return b"\0" in f.read(1024)
    except Exception:
        return True


def should_skip_dir(name: str) -> bool:
    return name.lower() in SKIP_FOLDERS


def safe_size(path: Path) -> int:
    """Ukuran sebenarnya di disk (follow symlink = False)."""
    try:
        return path.stat(follow_symlinks=False).st_size
    except Exception:
        return 0


def atomically_write_atom(out_path: Path, max_bytes: int, atoms: list[tuple[str, int]]):
    """
    atoms: [(blok_string, byte_len), ...]
    Jika total byte_len > max_bytes -> keluar sebelum menulis.
    Menulis secara streaming per blok; tetap utuh per atom.
    """
    total = sum(b for _, b in atoms)
    if total > max_bytes:
        print(
            f"Error: total calon output ({total / 1e6:.2f} MB) "
            f"melebihi --max-size ({max_bytes / 1e6:.2f} MB).\n"
            "Silakan naikkan --max-size atau batasi dengan --only.",
            file=sys.stderr,
        )
        sys.exit(2)

    tmp = out_path.with_suffix(out_path.suffix + ".tmp")
    try:
        with tmp.open("w", encoding="utf-8") as f:
            for blk, _ in atoms:
                # streaming write agar RAM tetap rendah
                for i in range(0, len(blk), CHUNK_SIZE):
                    f.write(blk[i : i + CHUNK_SIZE])
        tmp.replace(out_path)
    except Exception as e:
        try:
            tmp.unlink()
        except Exception:
            pass
        raise e


# ---------- signal handler ----------
class CleanExit:
    def __init__(self, path: Path):
        self.path = path
        signal.signal(signal.SIGINT, self._handler)
        signal.signal(signal.SIGTERM, self._handler)

    def _handler(self, signum, frame):
        print("\nDiterima sinyal interrupt. Menghapus file setengah jalan...", file=sys.stderr)
        try:
            self.path.unlink()
        except Exception:
            pass
        sys.exit(130)


# ---------- core ----------
def build_atoms(root: Path, base: Path) -> list[tuple[str, int]]:
    atoms: list[tuple[str, int]] = []
    for dirpath, dirnames, filenames in os.walk(base, followlinks=False):
        dp = Path(dirpath)
        rel_dp = dp.relative_to(root)

        # skip hidden
        if any(p.startswith(".") for p in rel_dp.parts):
            dirnames[:] = []
            continue
        # skip folder sampah
        for s in list(dirnames):
            if should_skip_dir(s):
                dirnames.remove(s)

        for fname in filenames:
            fp = dp / fname
            ext = fp.suffix.lower()
            if ext not in CODE_EXTENSIONS:
                continue
            if not fp.is_file() or fp.is_symlink():
                continue
            if is_binary(fp):
                continue

            rel = fp.relative_to(root).as_posix()
            header = f"===== {rel} =====\n"

            try:
                with fp.open("r", encoding="utf-8", errors="strict") as f:
                    content = f.read()
            except UnicodeDecodeError:
                continue

            block = header + content + "\n"
            atoms.append((block, len(block.encode("utf-8"))))
    return atoms


def main():
    parser = argparse.ArgumentParser(description="Dump kode utuh ke satu berkas teks.")
    parser.add_argument("root", help="Root folder proyek")
    parser.add_argument("--only", help="Hanya proses sub-folder tertentu")
    parser.add_argument("--max-size", type=int, default=50, help="Maksimum MB output (default 50)")
    parser.add_argument("--out", default=".", help="Folder keluaran")
    args = parser.parse_args()

    root = Path(args.root).expanduser().resolve()
    if not root.is_dir():
        print("Error: ROOT bukan direktori", file=sys.stderr)
        sys.exit(1)

    base = root
    if args.only:
        base = root / args.only
        if not base.is_dir():
            print(f"Error: {args.only} bukan folder di bawah {root}", file=sys.stderr)
            sys.exit(1)

    out_dir = Path(args.out).expanduser().resolve()
    out_dir.mkdir(exist_ok=True)
    out_file = out_dir / f"dump_code-{root.name}.txt"

    # Bangun daftar atom di memori sambil hitung total
    atoms = build_atoms(root, base)
    if not atoms:
        print("Tidak ada file kode yang ditemukan.", file=sys.stderr)
        sys.exit(0)

    # pasang handler Ctrl-C
    cleaner = CleanExit(out_file)

    # tulis atomik
    atomically_write_atom(out_file, args.max_size * 1_000_000, atoms)

    total_bytes = sum(b for _, b in atoms)
    print(f"Selesai. Output: {out_file}  ({total_bytes / 1e6:.2f} MB)")


if __name__ == "__main__":
    main()
